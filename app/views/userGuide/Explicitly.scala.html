@*
* Copyright 2010-2013 Artima, Inc.
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*@

@import controllers.Application.milestoneScaladoc

@userGuidePage("Explicitly") {
    <div style="text-align: left">

        <h1>Explicitly</h1>

        <p>
            ScalaUtils also includes an <a href="@{milestoneScaladoc}/index.html#org.scalautils.Explicitly"><code>Explicitly</code></a> DSL for defining an
            implicit <code>Equality</code> parameter <em>explicitly</em>. If you want to customize equality for a type in general, you would usually want to place an
            implicit <code>Equality[T]</code> for that type in scope (or in <code>T</code>'s companion object). That implicit equality definition will then be picked
            up and used when that type is compared for equality with the <code>equal</code> matcher in tests and with <code>===</code> in both tests and production code.
            If you just want to use a custom equality for a single comparison, however, you may prefer to pass it explicitly. For example, if you have an implicit
            <code>Equality[String]</code> in scope, you can force a comparison to use the default equality with this syntax:
        </p>

        <pre class="scala">
            // In production code:
            if ((result === "hello")(decided by defaultEquality)) true else false

            // In tests:
            result should equal ("hello") (decided by defaultEquality)
        </pre>

        <p>
            The explicitly DSL also provides support for specifying a one-off equality that is based on a normalization. For example, ScalaUtils has a
            <a href="@{milestoneScaladoc}/index.html#org.scalautils.StringNormalizations"><code>StringNormalizations</code></a> trait that provides
            <code>trimmed</code> and <code>lowerCased</code> methods that return <code>Normalization[String]</code>s that normalize by trimming and
            lower-casing, respectively. If you bring those into scope by mixing in or importing the members of <code>StringNormalizations</code>,
            you could use the explicitly DSL like this:
        </p>

        <pre class="scala">
            // In production code:
            if ((result === "hello")(after being lowerCased)) true else false

            // In tests:
            result should equal ("hello") (after being lowerCased and trimmed)
        </pre>

    </div>
}